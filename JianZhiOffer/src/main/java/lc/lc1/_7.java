package lc.lc1;

/*
* 整数反转
*
* 给你一个 32 位的有符号整数 x ，返回将 x 中的数字部分反转后的结果。
* 如果反转后整数超过 32 位的有符号整数的范围 [−231,  231 − 1] ，就返回 0。
* 假设环境不允许存储 64 位整数（有符号或无符号）。

输入：x = 123
输出：321
示例 2：

输入：x = -123
输出：-321
示例 3：

输入：x = 120
输出：21
*
* 实际上我们只要能拿到这个整数的 末尾数字就可以了。以12345为例，先拿到5，再拿到4，之后是3，2，1，
* 我们按这样的顺序就可以反向拼接处一个数字了，也就能达到反转的效果。怎么拿末尾数字呢？好办，用取模运算就可以了
* 循环的判断条件应该是while(x!=0)，无论正数还是负数，按照上面不断的/10这样的操作，最后都会变成0，所以判断终止条件就是!=0
* 有了取模和除法操作，对于像12300这样的数字，也可以完美的解决掉了。但请注意，题目上还有这么一句
* 假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−2^31,  2^31 − 1]。
* 也就是说不能用long存储最终结果，而且有些数字可能是合法范围内的数字，但是反转过来就超过范围了。
* */
//返回32位有符号整数x中数字反转后的结果。如反转后超过32位的有符号数范围就返回 0。例如x = 123翻转为321
public class _7 {
    public int reverse(int x) {
        int res = 0;
        while (x != 0) {
            //每次取末尾数字
            int tmp = x % 10;
            //判断是否 大于 最大32位整数
            if (res > 214748364 || (res == 214748364 && tmp > 7)) {
                return 0;
            }
            //判断是否 小于 最小32位整数
            if (res < -214748364 || (res == -214748364 && tmp < -8)) {
                return 0;
            }
            res = res * 10 + tmp; //更新res和x
            x /= 10;
        }
        return res;
    }
}
