package lc.lc1;

/*
* 盛最多水的容器
*
* 给定一个长度为 n 的整数数组 height 。有 n条垂线，第 i 条线的两个端点是 (i, 0) 和 (i, height[i]) 。
* 找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。
* 返回容器可以储存的最大水量。说明：你不能倾斜容器。
*
* 输入：[1,8,6,2,5,4,8,3,7]
输出：49
解释：图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。
*
*
[1, 8, 6, 2, 5, 4, 8, 3, 7]
 ^                       ^
在初始时，左右指针分别指向数组的左右两端，它们可以容纳的水量为 min(1,7)∗8=8。
此时我们需要移动一个指针。移动哪一个呢？直觉告诉我们，应该移动对应数字较小的那个指针（即此时的左指针）。这是因为，由于容纳的水量是由
两个指针指向的数字中较小值∗指针之间的距离决定的。因此，我们移动数字较大的那个指针是不合理的。因此，我们移动 数字较小的那个指针。
所以，我们将左指针向右移动：
[1, 8, 6, 2, 5, 4, 8, 3, 7]
    ^                    ^
此时可以容纳的水量为 \min(8, 7) * 7 = 49min(8,7)∗7=49。由于右指针对应的数字较小，我们移动右指针：
[1, 8, 6, 2, 5, 4, 8, 3, 7]
    ^                 ^
此时可以容纳的水量为 \min(8, 3) * 6 = 18min(8,3)∗6=18。由于右指针对应的数字较小，我们移动右指针：
[1, 8, 6, 2, 5, 4, 8, 3, 7]
    ^              ^
此时可以容纳的水量为 \min(8, 8) * 5 = 40min(8,8)∗5=40。两指针对应的数字相同，我们可以任意移动一个，例如左指针：
[1, 8, 6, 2, 5, 4, 8, 3, 7]
       ^           ^
此时可以容纳的水量为 min(6,8)∗4=24。由于左指针对应的数字较小，我们移动左指针，并且可以发现，在这之后左指针对应的数字总是较小，
因此我们会一直移动左指针，直到两个指针重合。在这期间，对应的可以容纳的水量为：min(2,8)∗3=6，min(5,8)∗2=10，min(4,8)∗1=4。
在我们移动指针的过程中，计算到的最多可以容纳的数量为 49，即为最终的答案。
* */
//一个长n整数数组height，第i条线两端点是(i, 0)和(i, height[i])，找两条线使它们与 x 轴构成容器可容最多水。返回最大水量
public class _11 {
    public int maxArea(int[] height) {
        int l = 0, r = height.length - 1;  //确定左右指针
        int ans = 0;
        while (l < r) { //循环判断条件
            //计算当前的面积，左右高度最小值*边界差
            int area = Math.min(height[l], height[r]) * (r - l);
            ans = Math.max(ans, area);  //更新最大面积
            if (height[l] <= height[r]) { //移动高度更小那边的指针
                ++l;
            } else {
                --r;
            }
        }
        return ans;
    }
}
