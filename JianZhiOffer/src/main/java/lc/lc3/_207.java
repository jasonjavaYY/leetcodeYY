package lc.lc3;

import java.util.ArrayList;
import java.util.List;

/*
* 课程表
*
* 你这个学期必须选修 numCourses 门课程，记为 0 到 numCourses - 1 。
在选修某些课程之前需要一些先修课程。 先修课程按数组 prerequisites 给出，其中 prerequisites[i] = [ai, bi] ，
* 表示如果要学习课程 ai 则 必须 先学习课程  bi 。例如，先修课程对 [0, 1] 表示：想要学习课程 0 ，你需要先完成课程 1 。
请你判断是否可能完成所有课程的学习？如果可以，返回 true ；否则，返回 false 。
示例 1：
输入：numCourses = 2, prerequisites = [[1,0]]
输出：true
解释：总共有 2 门课程。学习课程 1 之前，你需要完成课程 0 。这是可能的。
示例 2：
输入：numCourses = 2, prerequisites = [[1,0],[0,1]]
输出：false
解释：总共有 2 门课程。学习课程 1 之前，你需要先完成​课程 0 ；并且学习课程 0 之前，你还应先完成课程 1 。这是不可能的。
*
* 本题是一道经典的「拓扑排序」问题。
给定一个包含 n 个节点的有向图 G，我们给出它的节点编号的一种排列，如果满足：对于图 G 中的任意一条有向边 (u,v)，u在排列中都出现在 v 的前面。
那么称该排列是图 G 的「拓扑排序」。根据上述的定义，我们可以得出两个结论：
如果图 G 中存在环，那么图 G 不存在拓扑排序。假设图中存在环 x1,x2,⋯,xn,x1，那么 x1必须出现在 x_n前，但 xn也必须出现在 x1前，
* 因此不存在一个满足要求的排列；如果图 G 是有向无环图，那么它的拓扑排序可能不止一种。极端例子，如果图 G 值包含 n 个节点却没有任何边，
* 那么任意一种编号的排列都可以作为拓扑排序。我们将每一门课看成一个节点；如果要学课程 A 前必须完成课程 B，那么我们从 B 到A 连接一条有向边。
* 这样以来，在拓扑排序中，B 一定出现在 A 的前面。求出该图是否存在拓扑排序，就可以判断是否有一种符合要求的课程学习顺序。
* 由于求出一种拓扑排序方法的最优时间复杂度为 O(n+m)，其中 n 和 m 分别是有向图 G 的节点数和边数，方法见 210. 课程表 II 的官方题解。
* 而判断图 G 是否存在拓扑排序，至少也要对其进行一次完整的遍历，时间复杂度也为 O(n+m)。因此不可能存在一种仅判断图是否存在拓扑排序的方法，
* 它的时间复杂度在渐进意义上严格优于 O(n+m)。这样一来，我们使用和 210. 课程表 II 完全相同的方法，但无需使用数据结构记录实际的拓扑排序。
* 为了叙述的完整性，下面的两种方法与 210. 课程表 II 的官方题解 完全相同，但在「算法」部分后的「优化」部分说明了如何省去对应的数据结构。
* 方法一：深度优先搜索
我们可以将深度优先搜索的流程与拓扑排序的求解联系起来，用一个栈来存储所有已经搜索完成的节点。
对于一个节点 u，如果它的所有相邻节点都已经搜索完成，那么在搜索回溯到 u 的时候，u 本身也会变成一个已经搜索完成的节点。
* 这里的「相邻节点」指的是从 u 出发通过一条有向边可以到达的所有节点。假设我们当前搜索到了节点 u，如果它的所有相邻节点都已经搜索完成，
* 那么这些节点都已经在栈中了，此时我们就可以把 u 入栈。可以发现，如果我们从栈顶往栈底的顺序看，由于 u 处于栈顶的位置，
* 那么 u 出现在所有 u 的相邻节点的前面。因此对于 u 这个节点而言，它是满足拓扑排序的要求的。
这样以来，我们对图进行一遍深度优先搜索。当每个节点进行回溯的时候，我们把该节点放入栈中。最终从栈顶到栈底的序列就是一种拓扑排序。
算法
对于图中的任意一个节点，它在搜索的过程中有三种状态，即：
「未搜索」：我们还没有搜索到这个节点；
「搜索中」：我们搜索过这个节点，但还没有回溯到该节点，即该节点还没有入栈，还有相邻的节点没有搜索完成）；
「已完成」：我们搜索过并且回溯过这个节点，即该节点已经入栈，并且所有该节点的相邻节点都出现在栈的更底部的位置，满足拓扑排序的要求。
通过上述的三种状态，我们就可以给出使用深度优先搜索得到拓扑排序的算法流程，在每一轮的搜索搜索开始时，我们任取一个「未搜索」
的节点开始进行深度优先搜索。我们将当前搜索的节点 u 标记为「搜索中」，遍历该节点的每一个相邻节点 v：如果 v 为「未搜索」，
* 那么我们开始搜索 v，待搜索完成回溯到 u；如果 v 为「搜索中」，那么我们就找到了图中的一个环，因此是不存在拓扑排序的；
如果 v 为「已完成」，那么说明 v 已经在栈中了，而 u 还不在栈中，因此 u 无论何时入栈都不会影响到 (u,v) 之前的拓扑关系，以及不用进行任何操作。
当 u 的所有相邻节点都为「已完成」时，我们将 u 放入栈中，并将其标记为「已完成」。
在整个深度优先搜索的过程结束后，如果我们没有找到图中的环，那么栈中存储这所有的 n 个节点，从栈顶到栈底的顺序即为一种拓扑排序。
* */
//修numCourses门课。修某些课前要先修课程。数组prerequisites给出，prerequisites[i]=[ai, bi]表示学ai必须先学bi。判断能否学完所有课程
public class _207 {
    List<List<Integer>> edges;
    int[] visited; //标记某节点是否为搜索过0是未搜索，1是搜索中，2是已完成
    boolean valid = true; //标记是否存在可能的排序

    public boolean canFinish(int numCourses, int[][] prerequisites) {
        edges = new ArrayList<List<Integer>>(); //构造numCourses条边
        for (int i = 0; i < numCourses; ++i) {
            edges.add(new ArrayList<Integer>());
        }
        visited = new int[numCourses]; //构造标记数组，初始大小numCourses
        for (int[] info : prerequisites) { //遍历依赖数组，用依赖创建边
            edges.get(info[1]).add(info[0]);
        }
        for (int i = 0; i < numCourses && valid; ++i) {
            if (visited[i] == 0) { //如果第i和点没搜索过，搜索它
                dfs(i);
            }
        }
        return valid;
    }

    public void dfs(int u) {
        visited[u] = 1; //将节点标记为1搜索中
        for (int v : edges.get(u)) { //获取节点u需要的全部前置课程
            if (visited[v] == 0) { //如果前置课程v没搜索过，就搜索v
                dfs(v);
                if (!valid) { //如果不能找到，直接返回
                    return;
                }//如果前置课程也搜索中，则不能产生排序标记false返回
            } else if (visited[v] == 1) {
                valid = false;
                return;
            }
        }
        visited[u] = 2;//搜索完了所有前置课程，将u标记为2搜索结束
    }
}
