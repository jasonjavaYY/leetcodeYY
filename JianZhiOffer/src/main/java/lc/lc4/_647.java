package lc.lc4;

/*
* 回文子串
*
* 给你一个字符串 s ，请你统计并返回这个字符串中回文子串数。具有不同开始位置或结束位置子串，即使由相同字符组成，也被视作不同子串。
示例 1：
输入：s = "abc"
输出：3
解释：三个回文子串: "a", "b", "c"
示例 2：
输入：s = "aaa"
输出：6
解释：6个回文子串: "a", "a", "a", "aa", "aa", "aaa"
*
* 方法一：中心拓展
计算有多少回文子串的最朴素方法就是枚举所有回文子串，而枚举出所有的回文字串有两种思路，分别是：
枚举出所有子串，再判断这些子串是否是回文；枚举每一个可能的回文中心，然后用两个指针分别向左右两边拓展，当两个指针指向的元素相同时就拓展，否则停止。
假设字符串的长度为 n。前者会用 O(n^2)时间枚举出所有的子串 s[li⋯ri]，然后再用 O(ri−li+1) 时间检测当前子串是否回文，整个时间复杂度是 O(n^3)。
* 而后者枚举回文中心是 O(n)，对于每个回文中心拓展次数也是 O(n)，时间复杂度是 O(n^2)。我们需要处理一个问题，即如何有序地枚举所有可能的回文中心，
* 我们要考虑回文长度是奇数和是偶数两种情况。如果是奇数，那么回文中心是一个字符；如果是偶数，那么中心是两个字符。可以用一个循环搞定。不妨写一组
* 出来观察观察，假设 n=4，我们可以把可能的回文中心列出来：
编号i	回文中心左起始位置 l_i    回文中心右起始位置 r_i
0	           0	            0
1	           0	            1
2	           1	            1
3	           1	            2
4	           2	            2
5	           2	            3
6	           3	            3
可以看出长度为 n 的字符串会生成 2n−1 组回文中心 [li,ri]，其中 li=⌊ i/2 ⌋，ri=li+(i%2)。这样只要从 0 到 2n−2 遍历 i，
* 就可以得到所有可能的回文中心，这样就把奇数长度和偶数长度两种情况统一起来了。
* */
//回文串 字符串s，统计其中回文子串数(注意子串连续)。有不同开始结束位置的内容相同子串被视作不同子串
public class _647 {
    public int countSubstrings(String s) {
        int n = s.length(), ans = 0;//计算原字符串长度n，初始化ans=0
        for (int i = 0; i < 2 * n - 1; ++i) {//长n字符串有2n-1个回文中心[li,ri]
            int l = i / 2, r = i / 2 + i % 2;//li=⌊i/2⌋，ri=li+(i%2)
            //以[li,ri]为中心向外扩展，依次判断是否有回文子串，l和r不越界，不断判断l和r处字符是否相等，相等就扩展l和r，ans++
            //直到越界或者l和r处字符不相等退出循环，继续找下一个回文中心进行扩展
            while (l >= 0 && r < n && s.charAt(l) == s.charAt(r)) {
                --l; ++r; ++ans;
            }
        }
        return ans;//返回ans
    }
}
