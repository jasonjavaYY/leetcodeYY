package lc.lc4;

import java.util.HashMap;
import java.util.Map;
import java.util.Set;

/*
* 任务调度器
*
* 一个用字符数组 tasks 表示的执行任务列表。每个字母表示一种不同种类的任务。任务可以以任意顺序执行，且每个任务可以在 1 个单位时间执行完。
* 在任何一个单位时间，CPU 可以完成一个任务，或者处于待命状态。两个同种任务之间必须有长度为整数 n 的冷却时间，因此至少有连续 n 个单位时间内
*  CPU 在执行不同的任务，或者在待命状态。你需要计算完成所有任务所需要的最短时间 。
示例 1：
输入：tasks = ["A","A","A","B","B","B"], n = 2
输出：8
解释：A -> B -> (待命) -> A -> B -> (待命) -> A -> B
     在本示例中，两个相同类型任务之间必须间隔长度为 n = 2 的冷却时间，而执行一个任务只需要一个单位时间，所以中间出现了（待命）状态。
示例 2：
输入：tasks = ["A","A","A","B","B","B"], n = 0
输出：6
解释：在这种情况下，任何大小为 6 的排列都可以满足要求，因为 n = 0
["A","A","A","B","B","B"]
["A","B","A","B","A","B"]
["B","B","B","A","A","A"]
...
诸如此类
示例 3：
输入：tasks = ["A","A","A","A","A","A","B","C","D","E","F","G"], n = 2
输出：16
解释：一种可能的解决方案是：
     A -> B -> C -> A -> D -> E -> A -> F -> G -> A -> (待命) -> (待命) -> A -> (待命) -> (待命) -> A
     *
     * 思路与算法

首先考虑所有任务种类中执行次数最多的那一种，记为 A，执行次数为 maxExec。
我们使用一个宽为 n+1 的矩阵可视化地展现执行 A 的时间点。其中任务以行优先的顺序执行，没有任务的格子对应 CPU 待命状态。由于冷却时间为 n，
* 因此将所有的 A 排布在矩阵的第一列，可以保证满足题目要求，并且容易看出这是可以使得总时间最小的排布方法，总时间为：(maxExec−1)(n+1)+1
同理，如果还有其它也需要执行 maxExec 次的任务，也要将它们依次排布成列。例如，当还有任务 B 和 C 时，我们需要将它们排布在矩阵的第二、三列。
如果需要执行 maxExec 次任务数量为 maxCount，那么可以得到总时间为：(maxExec−1)(n+1)+maxCount,读者可能会对总时间产生疑问：
* 如果 maxCount>n+1，多出的任务无法排布进矩阵某一列，上面计算总时间的方法就不对了。把疑问放在这里，先「假设」一定有 maxCount≤n+1。
处理完执行次数为 maxExec 次的任务，剩余任务的执行次数一定都小于 maxExec，应当如何将它们放入矩阵呢？一种构造方法是，从倒数第二行开始，
* 按照反向列优先的顺序（即先放入靠左侧的列，同一列中先放入下方的行），依次放入每种任务，并且同一种任务要连续填入。例如还有任务D，E和F 时，
* 会按下图方式依次放入。对于任意一种任务，一定不会被放入同一行两次（否则说明该任务的执行次数大于等于 maxExec），并且由于我们按照列优先的
* 顺序放入这些任务，因此任意两个相邻的任务之间要么间隔 n（如上图中位于同一列的相同任务），要么间隔 n+1（如上图中第一列和第二列的 F），
* 都是满足题目要求的。因此如果按照这样方法填入所有任务，就可以保证总时间不变，仍然为：(maxExec−1)(n+1)+maxCount,
* 这些都建立在我们的「假设」之上，即不会填「超出」n+1 列。但想一想，如果真的填「超出」了 n+1 列，会发生什么呢？
* 上图给出了一个例子，此时 n+1=5 但我们填了 7 列。标记为 X 的格子表示 CPU 待命状态。看上去我们需要 (5−1)×7+4=32 的时间来执行所有任务，
* 但实际上如果我们填「超出」了 n+1 列，那么所有 CPU 待命状态都可以省去。因为 CPU 待命状态本身只是为了规定任意两个相邻任务的执行间隔至少为n，
* 但如果列数超过 n+1，就算没有这些待命状态，任意两个相邻任务执行间隔也会至少为 n。此时，总执行时间就是任务的总数 ∣task∣。
* 因此，在任意的情况下，需要的最少时间就是 (maxExec−1)(n+1)+maxCount 和 ∣task∣ 中的较大值。
* */
//数学 字符数组tasks表示任务列表。字母表示不同任务。任务需1时间。任1时间可完成一任务或待命。同任务间有n冷却，计算完成任务最短时间
public class _621 {
    public int leastInterval(char[] tasks, int n) {
        Map<Character, Integer> freq = new HashMap<Character, Integer>();
        int maxExec = 0; //最多的执行次数
        for (char ch : tasks) {//遍历任务列表，计算各类任务执行次数
            int exec = freq.getOrDefault(ch, 0) + 1;
            freq.put(ch, exec);
            maxExec = Math.max(maxExec, exec);//得到最后执行次数
        }
        int maxCount = 0; //具有最多执行次数的任务数量
        Set<Map.Entry<Character, Integer>> entrySet = freq.entrySet();
        for (Map.Entry<Character, Integer> entry : entrySet) {//遍历任务执行次数map
            int value = entry.getValue();
            if (value == maxExec) {//计算出最多执行次数的任务数count
                ++maxCount;
            }
        }//计算(maxExec−1)(n+1)+maxCount，和任务长度比较，返回较大值
        return Math.max((maxExec - 1) * (n + 1) + maxCount, tasks.length);
    }
}
