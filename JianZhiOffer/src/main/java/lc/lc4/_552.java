package lc.lc4;

/*
* 学生出勤记录 II
*
* 可以用字符串表示一个学生的出勤记录，其中的每个字符用来标记当天的出勤情况（缺勤、迟到、到场）。记录中只含下面三种字符：
'A'：Absent，缺勤  'L'：Late，迟到  'P'：Present，到场
如果学生能够同时 满足下面两个条件，则可以获得出勤奖励：A数量<2，最多连着2个L
按总出勤计，缺勤（'A'）少于两天。学生不存在连续 3 天或以上的迟到（'L'）。
给你一个整数 n ，表示出勤记录的长度。请你返回记录长度为 n 时，可能获得出勤奖励的记录情况 数量 。答案可能很大，所以返回对 10^9 + 7 取余结果。
示例 1：
输入：n = 2
输出：8
解释：
有 8 种长度为 2 的记录将被视为可奖励：
"PP" , "AP", "PA", "LP", "PL", "AL", "LA", "LL"
只有"AA"不会被视为可奖励，因为缺勤次数为 2 次（需要少于 2 次）。
示例 2：
输入：n = 1
输出：3
示例 3：
输入：n = 10101
输出：183236316
*
* 方法一：动态规划
由于可奖励的出勤记录要求缺勤次数少于 2 和连续迟到次数少于 3，因此动态规划的状态由总天数、缺勤次数和结尾连续迟到次数决定
* （由于不会记录连续迟到次数等于或多于 3 的情况，因此非结尾的连续迟到次数一定少于 3，只需要记录结尾连续迟到次数即可）。
定义 dp[i][j][k] 表示前 i 天有 j 个 ‘A’ 且结尾有连续 k 个 ‘L’ 的可奖励的出勤记录的数量，其中 0≤j≤1，0≤k≤2。
当 i=0 时，没有任何出勤记录，此时 ‘A’ 的数量和结尾连续 ‘L’ 的数量是 0，因此动态规划的边界情况是 dp[0][0][0]=1。
当 1≤i≤n 时，dp[i][][] 的值从 dp[i−1][][] 的值转移得到，计算每个状态的值需要考虑第 i 天的出勤记录：
如果第 i 天的出勤记录是 ‘P’，则前 i 天和前 i−1 天的出勤记录相比，‘A’ 数量不变，结尾连续 ‘L’ 数量清零，因此对 0≤j≤1，有
dp[i][j][0] = dp[i][j][0] + 2 ∑ k=0 dp[i−1][j][k]
如果第 i 天的出勤记录是 ‘A’，则前 i 天和前 i−1 天的出勤记录相比，‘A’ 的数量加 1，结尾连续 ‘L’ 的数量清零，此时要求前 i−1 天出勤记录记录中
* 的 ‘A’ 的数量必须为 0，否则前 i 天出勤记录至少有 2 个‘A’，因此有
dp[i][1][0] = dp[i][1][0]+ 2 ∑ k=0 dp[i−1][0][k]
如果第 i 天的出勤记录是 ‘L’，则前 i 天和前 i−1 天出勤记录相比，‘A’ 数量不变，结尾连续 ‘L’ 数量加 1，此时要求前i−1 天的出勤记录记录中的结尾
* 连续 ‘L’ 的数量不超过 1，否则前 i 天的出勤记录的结尾至少有 3 个 ‘L’，不满足可奖励的条件，因此对 0≤j≤1 和 1≤k≤2，有
dp[i][j][k] = dp[i][j][k]+dp[i−1][j][k−1]，上述状态转移方程对于 i=1 也适用。
计算长度为 n 的所有可奖励的出勤记录的数量，即为计算 dp[n][][] 所有元素之和。计算过程中需要将结果对 10^9+7取模。
* */
//动态规划 字符串表示出勤记录，字符标记当天情况'A'缺勤，'L'迟到，'P'到场。如同时满足：A数<2，最多连2个L则奖励，n表示出勤天。返回能获奖的情况数
public class _552 {
    public int checkRecord(int n) {
        final int MOD = 1000000007;//用来取余数
        //dp[i][j][k]表示前i天有j个‘A’且结尾连续k个‘L’的奖励出勤记录数，0≤j≤1，0≤k≤2
        int[][][] dp = new int[n + 1][2][3]; // 长度，A 的数量，结尾连续 L 的数量
        dp[0][0][0] = 1;//i=0没有出勤记录，‘A’数和结尾连续‘L’数是0，dp[0][0][0]=1
        //1≤i≤n时，dp[i][][]从dp[i−1][][]转移得到，需要考虑第 i 天出勤记录
        for (int i = 1; i <= n; i++) {//i从1到n
            //如果第i天是‘P’，则和前i−1天相比，‘A’数不变，结尾连续‘L’数清零，有
            //dp[i][j][0] = dp[i][j][0] + 2 ∑ k=0 dp[i−1][j][k]
            for (int j = 0; j <= 1; j++) {//j从0到1
                for (int k = 0; k <= 2; k++) {//k从0到2
                    dp[i][j][0] = (dp[i][j][0] + dp[i - 1][j][k]) % MOD;
                }
            }
            //如果第i天是‘A’，则和前i−1天相比‘A’数加1，结尾连续‘L’数清零，要求前i−1天记录中
            //‘A’数必须为0，，因此有dp[i][1][0] = dp[i][1][0]+ 2 ∑ k=0 dp[i−1][0][k]
            for (int k = 0; k <= 2; k++) {
                dp[i][1][0] = (dp[i][1][0] + dp[i - 1][0][k]) % MOD;
            }
            //如果第i天是‘L’，则和前i−1天相比‘A’数不变，结尾连续‘L’数加1，要求前i−1天结尾连续‘L’数不超1
            //因此对0≤j≤1 和 1≤k≤2，有dp[i][j][k] = dp[i][j][k]+dp[i−1][j][k−1]
            for (int j = 0; j <= 1; j++) {
                for (int k = 1; k <= 2; k++) {
                    dp[i][j][k] = (dp[i][j][k] + dp[i - 1][j][k - 1]) % MOD;
                }
            }
        }
        int sum = 0;
        for (int j = 0; j <= 1; j++) {//j从0到1，k从0到2
            for (int k = 0; k <= 2; k++) {//将dp[n][j][k]求和返回
                sum = (sum + dp[n][j][k]) % MOD;
            }
        }
        return sum;
    }
}
